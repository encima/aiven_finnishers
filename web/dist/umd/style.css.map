{
  "version": 3,
  "file": "style.css",
  "sources": [
    "../../src/SvelteTable.svelte"
  ],
  "sourcesContent": [
    "<script>\n\texport let columns;\n\texport let rows;\n\t\n\tlet sortOrder = 1;\n\tlet sortKey = \"\";\n\tlet sortBy = r => \"\";\n\tlet showFilterHeader = columns.some(c => c.filterOptions !== undefined);\n\tlet filterValues = {};\n\tlet filterSettings = {};\n\tlet columnByKey = {};\n\tcolumns.forEach(col => {\n\t  columnByKey[col.key] = col;\n\t});\n\n\t// $: console.log(filterSettings, filterValues);\n\t$: c_rows = rows\n\t  .filter(r =>\n\t    Object.keys(filterSettings).every(f => {\n\t      // console.log(f, filterSettings[f], columnByKey[f])\n\t      let ret =  (\n\t        filterSettings[f] === undefined ||\n\t        filterSettings[f] === columnByKey[f].filterValue(r)\n\t\t\t\t);\n\t\t\t\treturn ret;\n\t    })\n\t  )\n\t  .map(r => ({ ...r, $sortOn: sortBy(r) }))\n\t  .sort((a, b) => {\n\t    if (a.$sortOn > b.$sortOn) return sortOrder;\n\t    else if (a.$sortOn < b.$sortOn) return -sortOrder;\n\t    return 0;\n\t  });\n\n\tconst calculateFilterValues = () => {\n\t  filterValues = {};\n\t  columns.forEach(c => {\n\t    if (typeof c.filterOptions === \"function\") {\n\t      filterValues[c.key] = c.filterOptions(rows);\n\t    } else if (Array.isArray(c.filterOptions)) {\n\t      filterValues[c.key] = [...c.filterOptions];\n\t    }\n\t  });\n\t};\n\n\tconst handleSort = col => {\n\t  if (col.sortable === true && typeof col.value === \"function\") {\n\t    if (sortKey === col.key) {\n\t      sortOrder = sortOrder === 1 ? -1 : 1;\n\t    } else {\n\t      sortOrder = 1;\n\t      sortKey = col.key;\n\t      sortBy = r => col.value(r);\n\t    }\n\t  }\n\t};\n\n\tif (showFilterHeader) {\n\t  calculateFilterValues();\n\t}\n</script>\n\n<style>\n\ttable {\n\t  width: 100%;\n\t}\n\t.isSortable {\n\t  cursor: pointer;\n\t}\n\n\ttr th select {\n\t\twidth: 100%;\n\t}\n</style>\n\n<table>\n\t{#if showFilterHeader}\n\t\t<tr>\n\t\t  {#each columns as col}\n\t\t  \t<th>\n\t\t\t\t\t{#if filterValues[col.key] !== undefined}\n\t\t\t\t\t\t<select bind:value={filterSettings[col.key]}>\n\t\t\t\t\t\t\t<option value={undefined}></option>\n\t\t\t\t\t\t  {#each filterValues[col.key] as option}\n\t\t\t\t\t\t\t\t<option value={option.value}>{option.name}</option>\n\t\t\t\t\t\t  {/each}\n\t\t\t\t\t\t</select>\n\t\t\t\t\t{/if}\n\t\t\t\t</th>\n\t\t  {/each}\n\t\t</tr>\n\t{/if}\n\t<tr>\n\t  {#each columns as col}\n\t  \t<th on:click={() => handleSort(col)} class=\"{[(col.sortable ? 'isSortable' : '' ),(col.headerClass !== undefined && col.headerClass)].join(' ')}\">\n\t\t\t\t{col.title}\n\t\t\t\t{#if sortKey === col.key}\n\t\t\t\t\t{ sortOrder === 1 ? '▲' : '▼'}\n\t\t\t\t{/if}\n\t\t\t</th>\n\t  {/each}\n\t</tr>\n\t{#each c_rows as row}\n\t\t<tr>\n\t\t  {#each columns as col}\n\t\t  \t<td class=\"{col.class !== undefined && col.class}\">{@html col.renderValue ? col.renderValue(row) : col.value(row)}</td>\n\t\t  {/each}\n\t\t</tr>\n\t{/each}\n</table>\n"
  ],
  "names": [],
  "mappings": "AA+DC,KAAK,cAAC,CAAC,AACL,KAAK,CAAE,IAAI,AACb,CAAC,AACD,WAAW,cAAC,CAAC,AACX,MAAM,CAAE,OAAO,AACjB,CAAC,AAED,gBAAE,CAAC,EAAE,CAAC,MAAM,cAAC,CAAC,AACb,KAAK,CAAE,IAAI,AACZ,CAAC"
}